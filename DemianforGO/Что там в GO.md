- Простой синтаксис
- Мало синтаксического сахара
- Строгие правила форматирования

Есть:
- Инструменты для управления зависимостями, тестирование, форматирования и оптимизации кода.

Go - комплириуемый язык, с быстрым комплиятором. Можно комплириовать под разные операционные системы.

В Go есть модель конкурентного программирования, в языке есть такие абстракции как "горутины" и "каналы", которые позволят легко писать конкурентный код, при этом масштабировать его на несколько ядер процессора.

Не использует `;`

```GO
// определение пакета (неймспейса)
package main

// внешний пакет
import "fmt"

// логика программы находится в функции
func main() {
fmt.Print("Hello, world!")
}
```

`package` - Пакеты выполняют роль неймспейса, используется для группировки функций.
Все GO файлы начинаются с определения пакета, в котором он находится. Внутри одного пакета может быть множество функций.

`main` - главная функция GO, с неё начинается выполнение при запуске любой программы. Она не может принимать или возвращать какие-либо аргументы.

Для введения строки в терминал используется внешний пакет `frmt`. Импорт сторонних пакетов используется через `import`
После импорта можно вызывать функции пакета в своём коде:
`fmt.Print("Hello, World!")`

В данном случае сторонний пакет это "объект", а не неймспейс. Его можно использовать как префикс к функциям.
Обратиться к функции пакета можно через знак `.`.

Функции пишутся с большой буквы, а неймспейсы с маленькой.

[x] В GO функция является публичной если её имя пишется с заглавной буквы! Для приватности функции нужно её писать с маленькой буквы.
Приватные функции могут использоваться только внутри пакета.

[x] Строки пишутся в двойную ковычку. Есть также возможность использовать обратную ковычку.

[x] Нет точки с запятой.

[x] Чтобы компилятор понимал код, его нужно правильно переносить

[x] Использовать табуляцию вместо пробелов

----
GO - комплириуемый, строго типизируемый язык. Пример кода на языке:
```go
import (
"encoding/json"
"errors"
"fmt"
)

// struct в GO - составной тип данных, который может
type Message struct {
	Sender string `json:"sender"`
	Text string `json:"text"`
}

var errEmptyMessage = errors.New("Empty message")

// Отправляем ошибку в случае неожиданного поведения
func DecodeJson(rawMsg string) (Message, error) {
	if len(rawMsg) == 0 {
		return Message{}, errEmptyMessage
	}
	
msg := Message{}

//декодируем строку в структуру
err :=json.Unmarshal([]byte(rawMsg), &msg)
if err !=n nil {
	return Message{}, fmt.Errorf("unmarshal: %w", err)
	}
}
```

[x] В GO нет Exceptions, но есть интерфейс errors. Ошибки возвращаются последним аргументом из функции.
Потому GO-код выглядит как череда вызовов функции и проверки на ошибки:
```go
func main() {
	msg, err := DecodeJSON("")
	if errors.Is(err, errEmptyMessage) {
	// выдаст { } пустое сообщение
	fmt.Println(msg, err)
	}

	msg, err = DecodeJSON("hello")
	if err != nil {
	// выдаст { } unmarshal: invalid character 'h' looking for beginning of value
	fmt.Println(msg, err)
	}

	msg, err = DecodeJSON(`{"sender": "hexlet", "text":"Go-Go-Go"}`)
	// выдаст {hexlet Go-Go-Go} <nil>
	fmt.Println(msg.err)
}
```

Такой подход может быть не изящным, но позволяет ловить иконтролировать все ошибки в коде.

----
Самая сильная сторона GO - написание конкурентных программ. Для этого в языке используются легковесные потоки - `горутины`.
Пример программы, которая суммирует 10 значений из разных внешних источников:
```go
import (
	"fmt"
	"sync"
)

func main() {
	mu := sync.Mutex{}
	wg := sync.WaitGroup{}

	sum := 0

	for i := 0; i <10; i++ {
		wg.Add(1)
	}

	// установка префикса go перед функцией заставляет её выполняться параллельно в горутине
	go func() {

		// делаем долгий вызов к стороннему API. Так как вызов происходит в своей горутине, мы делаем 10 вызовов одновременно.
		n := externalHTTPNum()

		mu.Lock()
		sum += n
		mu.Unlock()

		wg.Done()
	}()
	// ждём пока горутина сформирует ответ по всем 10 запросам
	wg.Wait()

	fmt.Printl(sum)
}
```