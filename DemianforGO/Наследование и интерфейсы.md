В GO отсутствует понятие наследования в классическом виде (нет extends). Потому реализация наследования происходит другими средствами.

Наследование нужно:
1. Чтобы повторно использовать код: наследние получает всё содержимое прекда.
2. Динамический полиморфизм: переменная может ссылаться как на базовый класс, так и на класс-наследник
3. Динамическая диспетчеризация: метод с одним и тем же названием может иметь разную реализацию в классе предке и наследователе

Для наследования используется `композиция` и `встраивание`.

----
#### Композиция
Берёшь вторую структуру и впихиваешь туда свою базовую структуру:
```go
type Car struct {
	// something
}

type FireTruck struct {
	basis Car

	// something else
}
```

----
#### Встраивание
Повторно использовать код можно через встраивание, используя делегирование:
```go
type Car struct {
	// something
}

// Вот видимо так тупо добавляются методы к структурам 0_о
func (c *Car) Drive() {
	fmt.Println("Driving thru")
}

type FireTruck struct {
	basis Car
}

func (fe *FireEngine) Drive() {
	fe.basis.Drive()
}
```

Чтобы сократить конструкцию и не дублировать код, то:
```go
type Car struct {
	// something
}

func (c*Car) Drive() {...}

type FireTruck struct {
	Car
	// something else
}
```

---
#### Интерфейсы
Интерфейс опредеояет что тип делает (а не кем он является).
Методы должны отражать поведение типа, поэтому интерфейсы объявляются с набором методов, которые тип должен обязательно иметь.
Например метод Drive()

```go
type IDriveable {
Drive()
}

type Car struct {

}

type PoliceCar struct {

}

func (c Car) Drive() {
	fmt.Println("Just passing thru")
}

func (pc PoliceCar) Drive() {
	fmt.Println("Moving with the noise")
}

func main() {
	// Вот видимо так добавляются к интерфейсу структуры
	cars := []IDrivable{&Car{}, &PoliceCar{}}
	for _, vegicle : range cars {
	vehicle.Drive
	}
}
```

[x] В GO не указывается явно что тип реализует интерфейс. То есть типы с методом интерфейса неявно его наследуют.

[x] Называть интерфейсы I + verb + able - признак хорошего тона в программировании, но только в GO опять всё через ж_пу.