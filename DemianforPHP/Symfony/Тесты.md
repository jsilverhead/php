Для тестирования в Symfony используется фреймворка PHPUnit.

Если не установлен, то можно его добавить через composer:
```temrinal
composer require --dev symfony/test-pack
```

После установки фреймворка нужно попробовать его запустить:
```terminal
php bin/phpunit
```

Данная команда запускает тесты приложения. Каждый тест - класс PHP, который заканчивается на постфикс `test`, как `UserAuthTest` и которые находятсв в каталоге /test приложения.

Настраивается тестирование через файл `phpunit.xml.dist` в корне приложения.

<!> Symfony Flex автоматически создаёт `phpunit.xml.dist` и `tests/bootstrap.php`. Если не создал, то можно запустить команду:
```terminal
composer recipes:install phpunit/phpunit --force -v
```

----
### Виды тестов
В Symfony существуют следующие зафиксированные виды тестов:
- **Юнит тесты** - гарантирует что отдельные еденицы кода (например, отдельный класс) ведут себя как задумано.
- **Интеграционные тесты** - тестируют комбинацию классов и обычно взаимодействуют с контейнером сервисов Symfony.
- **Эпликейшн тесты** -тест, который проверяет поведение приложения целиком. Делает HTTP-запрос, как реальный, так и смоделированный.

----
#### Юнит тесты
Тест гарантирует, что отдельные единицы исходного кода (класс/метод) соответствуют дизайну и ведут себя так как задумано.

По соглашению `/tests` каталог должен копировать каталог вашего приложения для модульных тестов. Так что если тестируешь класс `src/Form`, то помести тест в `tests/Form`.
Автозагрузка автоматически включается через `vendor/auotload.php`.

Можно запустить конкретный тест по команде:
```terminal
php bin/phpunit tests/Form
```

Или на конкретный класс:
```terminal
php bin/phpunit tests/Form/FromSubmitTest.php
```

<!> В больших тестовых набор может иметь смысла создавать подкаталоги для каждого типа тестов:
- `tests/Unit/`
- `tests/Integration`
- `tests/Application`

----
#### Интеграционные тесты
По сравнению с юнти-тестами будет тестировать какую-то часть приложения. Интеграционные тесты могут использовать ядро Symfony для извлечения сервиса из контейнера DI.

В Symfony есть KernelTestCase, который позволяет создавать и загружать ядро в тестах:
```php
class NewsLetterGeneratorTest extends KernelTestCase
{
	public function testSomething():void
	{
		self::bootKernel();

		//...
	}
}
```

Также KernelTestCase гарантируется перезагрузка ядра для каждого теста. Это гарантирует выполнение тестов <u>независимо друг от друга</u>.

Для запуска тестов приложения, `KernelTestCase` класс должен найти ядро приложения для инициализации. Класс ядра обычно определяется в `KERNEL_CLASS` переменной окружения (включенной в `.env.test` файл по умолчанию):
```env.test
KENEL_CLASS=App\Kernel
```

Если вариант использования более сложный, можно переопределить методы `getKernelClass()` и `createKernel()` в функциональном тесте, которые будут иметь приоритет над `KERNEL_CLASS` в .env

----
#### Настройка тестовой среды
Тесты создают ядро. которое работает в `test` окружении. Это позволяет иметь специальные настройки для тестов внутри `config/packages/test/`

Twig конфиг, который настроен на тесты:
```php
#config/packages/test/twig.php
return static function (TwigConfig $twig): void {
	$twig->scrictVariables(true);
};
```

Можно использовать другую среду в настройках или переопределить режим отладки в методе `bootKernel()`:
```php
self::bootkernel([
	'environment' => 'my_test_env',
	'debug' => false,
])
```

<!> Рекомендуется запустить тест с debug значением `false` на сервере CI, так как это повышает производительность теста. Отключет отчистку кэша. Если запускаешь в чистой среде каждый раз придётся кэш очищать вручную, используя этот код:
```php
(new \Symfony\Component\Filesystem\Filesystem()->remove(__DIR__.'/..))
```

----
#### Настройка env
Если необходимо настроить переменные среды для тестов, например DATABASE_URL, который использует Doctrine, можно добавить это в `.env.test` файле:
```env
DATABASE_URL = "mysql://db_user:db_password@127.0.0.1:3306/db_name_test?serverVersion=8.0.37"
```

В тестовой среде участвуют следующие env файлы:
1. `.env` - содержит значения приложения по умолчанию
2. `.env.test` - переопределение/установка определённых тестовых значений переменных
3. `.env.test.local` - переопределение настроек, специфичной для локальной машины

[x] файл `.env.local` не используется в тестовой среде, чтобы сделать каждую тестовую настройку максимально единообразной.

----
#### Получение услуг в тесте
В интеграцинонных тестах часто нужно извлечь службу из контейнера служб, чтобы вызвать определённый метод. Для загрузки ядра контейнер возвращается static::getContainer():
```php
class NewsletterGeneratorTest extends KernelTestCase

public function testSomething():void
{
	// загрузить symofny из ядра kernel
	self::bootKernel();

	// Используй для доступа к service container
	$container = static::getContainer();

	// Используй сервис и протестируй результат
	$newsLetterGenerator = $container->get(NewsletterGenerator::class);
	$newsLetter = $newsletterGenerator->generateMonthlyNews(/* ... */);

	$this->assertEquals('...', $newsletter->getContent());
}
```
Контейнер из `static::getContainer()` на самом деле является специальным тестовым контейнером.
Он даёт вам доступ как к публичным сервисам, так и к не удалённым приватным сервисам.

[x] Если вам необходимо протестировать приватные сервисы, которые были удалены, необходимо объявить эти частные службы в `config/services_test.yaml` файле как публичные.

----
#### Имитация зависимостей
Иногда может быть полезно имитировать зависимость тестируемой службы:
```php
class NewsletterGeneratorTest extends KernelTestCase
{
	public function testSomething():void
	{
		$newsRepository = $this->createMock(NewsRepositoryInterface::class);
		$newsRepositore->expets(self::once())
		->method('findNewsFromLastMonth')
		->willReturn([
			new News('some news'),
			new News('some other news')
		]);
	$container->set(NewsRepositoryInterface::class, $newsRepository);

	$newsletterGenerator = $container->get(NewsketterGenerator::class);

	// ...
	}
}
```

----
#### Настройка БД для тестов
Тесты, взаимодействующие с БД должны использвать собственную, отдельную базу данных, чтобы не мешать базам данных, используемым в других env'ах.

Дл этого отредактируйте или создайте `.env.test.local` файл в корневом каталоге вашего проекта и определите новое значение для переменной `DATABASE_URL` env:
```env
#.env.test.local
DATABASE_URL="mysql://USERNAME:PASSWORD@127.0.0.1:3306/DB_NAME?serverVersion=8.0.37"
```

Это предполагает, что каждый разработчик использует собственную БД для тестов.
Если нужна одинакова настройка, то нужно добавить этот env файл в общем репозитории.

После этого можно создать тестовую БД, через терминал:
```terminal
# Создаёт тестовую БД
php bin/console --env=test doctrine:database:create

# Создаёт таблицы/колонки в тестовой БД
php bin/console --en=test doctrine:schema:create
```

<!> Можно запустить эти команды во время процесса тестовой загрузки.

<!> Распространённой практикой является добавление `_test` суффикса к исходным именам баз данных в тестах. Если имя базы данных на проде называется `project_acme` имя тестовой базы данных может быть `project_acme_test`.

----
##### Автоматический сброс БД перед каждым тестом
Тесты должны быть независимы друг от друга, чтобы избежать побочных эффектов. Для этого используется пакет DAMADoctrineTestBundle, который использует транзакции Doctrine, чтобы каждый тест мог взаимодействовать с неизменённой базой данных:
```terminal
composer require --dev dama/doctrine/test-bundle
```
В php.unit.xml.dist используем следующую строчку:
```xml
<phpunit>
	<extensions>
		<extension class="DAMA\DoctrineTestBundle\PHPUnit\PHPUnitExtension" />
	</extensions>
</phpunit>
```

Он начинает транзакцию во время старта теста, а после окончания - откатывает её.

----
##### Загрузить фиктивные данные Fixtures
Вместо реальных данных из данных прода, в тестовой БД часто используются поддельные данные - фикстуры.
Doctrine предоставляет библиотеку для их создания и загрузки.
```terminal
composer require --dev doctrine/doctrine-fixtures-bundle
```

Затем используй команда `make:fixtures` в консоли для генерации путого класса фикстуры:
```
php bin/console make:fixtures

# Имя класса, на который нужно сделать фикстуру
>ProductFixture
```

Затем можно изменять и использовать этот класс для загрузки новых сущностей в БД.
Например, чтобы загрузить `Product` объект в Doctrine, используй:
```php
class ProductFixture extends Fixture
{
	$product = new Product();
	$product->setName('Priceless widget');
	$product->setPrice(14.50);
	$product->setDescription('Ok, I guess it does have a price');
	$manager->persist($product);

	//  добавь ещ> продуктов

	$manager->flush();
}
```

Очистить базу и перезагрузить фикстуры можно через:
```terminal
php bin/console --env=test doctrine:fixtures:load
```

----
### Тест приложений
Тесты проверяют тест всех слоёв приложения. Ничем не отличается от модульных или интеграционных тестов, но у них специфичный рабочий процесс:
1. Сделать запрос
2. Взаимодействовать со страницей
3. Протестировать ответ
4. Вычистить и повторить

----
#### Вступительный тест:
Тесты - php файлы, которые обычно находятся в `tests/Controller/`.
Они часто расширяют WebTestCase - класс, который добавляет логику поверх KernelTestCase.

Можно создать тест для контроллера через команду в терминале:
```terminal
php bin/console make:test

#Выбери тип теста
>WebTestCase

#Указываем имя для класса
>Controller\PostControllerTest
```

Подобная команда создаётся следующий класс:
```php
class PostContollerTest extends WebTestCase
{
	public function testSomething():void
	{
		$client = static::createClient();

		$crawler = $client->request('GET', '/');

		$this->assertResponseIsSuccesful();
		$this->assertSelectorTextContaints('h1', 'Hello World');
	}
}
```

Данный тест проверяет что ответ по запросу успешен и что в теле ответа находится тег h1 со словами Hello World.

