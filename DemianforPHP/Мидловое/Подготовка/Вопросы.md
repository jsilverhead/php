##### С чем работал?

PHP 8.1 - 8.4, Symfony 7, PostgreSQL 14 и 17, Docker, и совсем немного Terraform

##### Как хранить пароль? Что такое хэширование?

Пароль хранится в хэшированном виде. Пароль хэшируется bcrypt, argon, SHA…

Строка при помощи алгоритма и secret формируется в строку, в которую зашифрованы данные.

Популярные решения: с солью, bcrypt, argon

##### Какие особенности хэширования?

Хэширование односторонее, то есть нет возможности из хэшированного пароля сформировать обратно читаемую строку.

##### Нужно ли в PHP думать о памяти и заниматься сбором мусора и очисткой?

Нет, обычно за это отвечает интерпретатор.
Ожидает какое-то количество ссылок на неиспользуемый ресурс и сам очищает.

Есть два механизма: сбор ссылок на неиспользуемые объекты и удаление неиспользуемых переменных.
Но существует некоторые моменты, когда нужно думать о памяти - большие и сложные вычисления, большое количество объектов.

##### Расскажи что такое JWT и как с ним работать?

JWT это закодированный json в виде строки. 
JWT кодируется с помощью secret, и с помощью него можно также декодировать строку в массив.

Состоит из 3 частей: Header (метаданные о типе токена, алгоритме), Payload (содержит данные + exp и iss), Signature - секретный ключ, которая декодирует токен.

Сигнатура обеспечивает понимание что токен не был изменён после создания.

##### Что знаешь про конкурентный доступ? Race Conditions, Deadlock?

Конкурентный доступ это когда два или более ресурса пытаются достучаться до одной точки данных.
Часто встречается в БД. 

Race Conditions - гонка доступа, то есть первый достучавшись получает доступ к изменению данных.

Deadlock - в случае когда несколько ресурсов одновременно пытаются изменить данные, и транзакция ожидает другую транзакцию, блокируя намертво выполнение.
Избавиться от Deadlock можно: короткими транзакциями (чем быстрее - тем лучше), `SELECT FOR UPDATE` (оптимизация запроса), настраивать таймауты.
Также высокие уровне изоляции транзакций увеличивают риск Deadlock. Оптимально - `READ COMMITED`.
Либо использовать Retry.

##### Расскажи про SOLID?

Принцип, который позволяет формировать читаемый код. Снижает связываемость, и увеличивает связку.

S - Single Responsibility - каждый класс или функция должна обеспечивать только одного актора (отвечать за одно действие) ИЛИ (причина для изменения должна быть только одна).

O - Open Close - классы должны быть открыты для расширения, а не для изменения.

L - Liskov Principle - наследуемый класс не должен менять сигнатуру родительского класса. А также классы должны меньше знать друг о друге.

I - Interface Segregation - нет смысла делать суперинтерфейсы, особенно если в наследумых классах они используются только частично. Лучше разделить интерфейсы на несколько небольших.

D - Dependency Inversion - модули верхнего уровня не должны быть жёстко завязаны на модулях нижнего уровня. Принцип при котором классы не должны быть жёстко завязаны друг на друга, а лучше использовать интерфейс или абстракцию.

Например при реализации отправки сообщений лучше использовать Intreface, который поддерживает несколько типов доставки, а не завязываться на конкретном.

##### ООП?

В основу разработки ООП - вкладывается работа с объектами и классами.

Класс - инкапсулированный набор методов и свойств.
Объект - экземпляр класса.

- **Инкапусляция** - данные и методы объединяются в класс, который закрыт от внешнего мира и позволяет работать с внутренними данными только через публичные методы.
- Наследование - можно создать класс на основе предыдущего, при том что дочерний **класс** унаследует методы и свойства родительского класса. Это помогает не повторяться в коде и реализовывать специфические кейсы на основе дочерних классов.
- **Полиморфизм** - способность объектов по разному реагировать на вызов одного и того же метода. Это создаёт единый интерфейс с разными реализациями одного типа объектов.
- **Абстракция** - выделение ключевых характеристик объекта, которые нужны для создания объекта, со скрытой деталью реализации.

##### Как в БД брать данные в виде пагинации?

1. Использовать LIMIT и OFFSET в SQL команде. НО (!) OFFSET - пробегает по базе последовательно, потому в итоге может потребовать слишком много памяти. 
2. Добавить дополнительное поле типа `sequence`, с которого будет идти отсчет.

##### Что такое транзакция?

Это инкапсулированный набор команд, который работает по принципу “ВСЁ или НИЧЕГО”.  
По сути одна команда - тоже своего рода транзакция.  
Если требуется при этом оформить набор команд, в таком случае транзакция заворачивается в команду BEGIN TRANSACTION а заканчивается командой COMMIT

##### Что такое ValueObject?

Не мутабельный объект, который отвечает за некое поле и имеет свою внутреннюю логику. В отличии от Entity не имеет таблицы в БД и не имеет индетификатора.

##### Если нужно достать все записи в процессе оплаты? Стоит ли навешать индекс на поле статус оплаты?

Нет, потому что это часто-изменяемое поле с низкой уникальностью данных. Чаще всего индексируют поля с высокой уникальностью.

##### Разумно ли вешать индекс на дату регистрации? 

Не стоит. Индекс плохо работает с больше-меньше.

##### Почему не принято использовать latest версии в docker-compose?

Из-за нестабильности и непредсказуемости изменений в последних версиях.

##### Как ускорить сборку docker?
1. Использовать multistage-build.
2. Кэширование слоёв
3. Использовать dockerignore чтобы избегать лишних файлов

##### Как снизить размер контейнера в docker?
1. Использовать -alpine / -slim версии образов.
2. Multi-stage сборка
3. Удалять кэш пакетных менеджеров
4. Минимизровать слои, объединив их в одну RUN команду
5. dockerIgnore

##### Что не нужно индексировать в БД?
- Столбцы с низкой селективностью
- Часто изменяемые столбцы
- Большие текстовые и бинарные данные
- Столбцы, которые не испольщуются в WHERE/JOIN/ORDER BY
- Маленькие таблицы

##### Репликация и шардирование - что такое и зачем?

Репликация - механизм копирования данных из master в slave. Нужно для:
- Отказоустойчивости
- Распределения нагрузки

Шардирование - горизонтальное распределение данных между разными серверами (шардами) по правилу:
- По диапазону.
- По хэшу.
- По географическому признаку.

Разница между ними:
- Репликация полностью копирует данные
- Шардирование - разбивает данные по разным устройствам

##### Что делать если клиент читает данные с slave, которые не успели реплицироваться?

1. Читать с Master (Read-After-Write Consistency)
2. Ожидать репликации
3. Кэш данных - читать из кэша до реплиации