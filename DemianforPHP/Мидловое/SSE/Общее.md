Данный микросервис позволяет отправлять события пользователя со стороны backend.
Сервис однонаправленный, но в некоторых кейсах его можно использовать взамен Websocket.

#### Что в секретках?
- `DOCKER_REGISTRY_HOST` - адрес докер registry, например `cr.yandex`
- `DOCKER_REGISTRY_ID` - ID докер registry, например `notabenne2007`
- `DOCKER_REGISTRY_NAME` - имя докер registry, например `server-sent-event-service`

В итоге будет сформирован такой адрес: `cr.yandex/notabenne2007/server-sent-event-service`

- `DOCKER_USERNAME` - имя пользователя, от которого будут пушится образы в реестр
- `DOCKER_PASSWORD` - пароль пользователя, от которого будут пушится образы в реестр

#### Конфигурация:
1. Поднять ограничение по потребляемым ресурсам. Например количество файловых дескрипторов, которые может открыть процесс SSE:
```config
ulimit -n 65536
```

Проверить лимиты на Linux:
```bash
cat /proc/<PID>/limits
```

Пример конфигурации:
```bash
systcl -w fs.file-max=12000500
systcl -w fs.nr_open=20000500
ulimit -n 2000000
```

2. Возможно потребуется увеличить лимиты открытых файлов для nginx.

- Сервис может упасть, поднять его потребуется вручную
- Если сервис запущен в Kubernetes, то можно настроить `restartPolicy: Always` для автоматической перезагрузки сервиса

#### Переменные окружения
- `REDIS_URL` - URL редис сервиса
- `REDIS_USERNAME` - Username подключения к редис
- `REDIS_PASSWORD` - Password подключения к редис
- `REDIS_DB` - идентификатор БД в редис
- `REDIS_CHANNEL` - канал, который будет использоваться для отправки и чтения сообщений в редис
- `APP_ENV` - переменная окружения: test | prod
- `JWT_PUBLIC_KEY` - публичный ключ для валидации jwt
- `JWT_ISSUER` - значение, которое указывается в iss при создании jwt
- `INTERNAL_EVENTS_STRATEGY` - будет ли приложение генерировать события, такие как `user-connected`, `user-disconnected`: generate | ignore

- Логи пишутся в stdout
- SSE поддерживает CORS. На данный момент поддерживаются запросы с любого ориджина: `Access-Control-Allow-Origin: *`

#### Отправка сообщений:
Чтобы отправить event пользователю из бекенда нужно положить в Redis сообщение данного вида:
```json
{
"to": [
	"663ae0a9-3560-1234-8f76-a785c0ed2008",
	"999ae0a9-4960-4760-8f76-a785c0ed2007"
],
"event": "eventName",
"message": "any string"
}
```

Данное сообщение будет отправлено всем "адресатам" в массиве `to`.

#### JWT аутентификация:
Ожидает следующие параметры:
```json
{
"userId": "999ae0a9-4960-4760-8f76-a785c0ed2007",
"iss": "project_api",
"exp": 1669132721
}
```

#### Внутренние события
Сервис умеет самостоятельно генерировать внутренние события:
- `user-connected` - пользователь подключился к сервису
- `user-disconnected` - пользователь отключился от сервиса
- `on-connection` - вернёт список online пользователей на данный момент

Когда пользователь подключается к сервису, остальным пользователям отправляется сообщение `user-connected`
При отключении отправляется `user-disconnected`

#### Схема работы сервиса
API → Redis Producer → Pub/Sub → SSE service → Frontend

#### Возможные ошибки
- В ответ на создание подключения с SSE сервисом возвращаются ошибки формата API Problem.
- Признаком ошибки является заголовок content type: `application/problem+json`
- Ошибка состоит из двух полей:
	- type - идентификатор ошибки
	- detail - человекочитаемое описание ошибки
- Пример сообщения об ошибке:
```json
{
	"type": "invalid_jwt",
	"detail": "Invalid JWT token"
}
```

#### Возможные проблемы
- Прокси, такие как nginx имеют ограничение на количество подключений. В конфигурации необходимо указать точное количество возвожных подключений.
- Может быть проблема с эфимерными портами при большом количестве подключений, что можно решить:
	- Увеличением диапазона `ip_local_port_range`
	- Увеличением экземпляров SSE для распределения нагрузки
	- Увеличением экземпляров балансировщика
	- Использованием виртуальных сетевых интерфейсов VIF
