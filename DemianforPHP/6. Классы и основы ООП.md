ООП - подход в разработке, подразумевающий организацию кода при помощи Объектов (классов).

Пример класса:
```php
Class Example {
	public string $name;
	public int $id;
}
```

Для доступа к классу необходимо создать экземпляр класса путём создания переменной и команды new:
```php
Class Example {
	public string $name;
	public int $id;
}

$sample1 = new Example;
```

Переменные в классах называются "Свойства класса".
Функции в классах называются "Методы класса".

Пример:
```php
Class Example {
	public string $name;
	public int $id;

	public function getName(){
		return this->name;
	}

$sample = new Example;
echo $sample->getName();
}
```

Экземпляры класса
--
Экземпляр класса можно задать оператором `new` или через string переменную.
```php
class Sandbox
{
}

$sanbox = new Sandbox;

// OR

$class = 'Sandbox';
$sandbox2 = new $class();
```

Также экземпляры класса можно создать несколькими способами:
```php
class Sandbox
{
    public static function newObj()
    {
        return new static();
    }
}

$one = new Sandbox; // по имени класса

$two = new $one(); // по имени экземпляра класса

$three = Sandbox::newObj(); // по внутренней функции

$four = Child::newObj(); // по дочернему классу
```

Можно обратиться к свойству или методу только что созданного экземпляра путём структуры:

```php 
class Sandbox
{
    public string $currentYear = '2024';
}

echo (new Sandbox())->currentYear;
```

Свойства и методы
--
Свойства и методы могут иметь одинаковую нотацию, и что вызовет экземпляр класса зависит от контекста.

```php
class Sandbox
{
    public $result = 42;
    
    public function result()
    {
        return 24;
    }
}

$sandbox = new Sandbox;

echo $sandbox->result(), PHP_EOL;

echo $sandbox->result;
```

С анонимной функцией такое провернуть можно, используя конструкция вызова через скобки.

```php
class Sandbox

{
    public $result;
    public function __construct()
    {
        $this->result = function () {

            return 'result is 42';
        };
    }
}

$newObj = new Sandbox;

echo ($newObj->result)(); // выведет result is 42
```

Final
--
Ключевое слово `final` не даёт дочерним классам предопределять методы или свойства, а также наследовать класс если `final` относится к классу.

```php
class Sandbox

{
    public int $num = 1;

    final public function getNum()
    {
        return $this->num;
    }
}

class box extends Sandbox
{
    public function getNum()
    {
        return $this->num + 1; // ВЫЗОВЕТ ОШИБКУ
    }
}
```

Пример final класса:
```php
final class Sandbox
{
    public function box()
    {
        return 'box';
    }
}

class box extends Sandbox // ВЫЗОВЕТ ОШИБКУ
{
}
```

Свойства нельзя делать окончательными, только классы, методы, константы.

```php
class Sandbox
{
    final public const PI = 3.14;
}

class box extends Sandbox
{
    public const PI = 2; // вызовет ошибку
}
```

Константу можно менять в дочернем классе, только если она не final.
**Область видимости:**
--

Существуют настройки области видимости.
`public` - доступна во всех местах кода
`private` - доступна только в рамках экземпляра класса
`protected` - доступна в рамках класса и дочерних классов

`Геттеры` - публичные методы, которые позволяют получить доступ к просмотру свойства класса. Существуют также магический метод геттера.
`Сеттеры` - публичные методы, которые позволяют получить доступ к изменению свойства класса. Существуют также магический метод сеттера.

Пример:
```php
class Example

{
    private int $id = 21;
    
    public function getId()
    {
        return $this->id;
    }
}

$sample = new Example;
echo $sample->getId(); // для получения доступа к приватному свойству использован геттер
```

```php
class Example

{
    protected int $id = 99;
}

class Sample extends Example
{
    function getId()
    {
        echo $this->id;
    }
}
 
$samp = new Sample;

$samp->getId(); // выведет id

$samp->$id = 30; // выведет ошибку
```

**Конструкторы и деструкторы**
--

Существуют магические функции, которые используются при создании экземпляра класса.
`__construct()` - магический метод, который автоматически вызывается при создании экземпляра класса.

Пример:
```php
class Example
{
    public string $name;
    public int $id;

    public function __construct($name, $id)
    {
        echo "New user created\n";
        $this->name = $name;
        $this->id = $id;
    }
}

$sample = new Example("Афанасий", 22);

echo "Username: {$sample->name}";
```

`__desctruct()` - магический метод, который уничтожает класс после его "отработки", срабатывает в конце "отработки" класса. Делается это для освобождения памяти.

Пример:
```php
class Example
{
    public string $name;
    public int $id;

    public function __construct($name, $id)
    {
        echo "New user created\n";
        $this->name = $name;
        $this->id = $id;
    }

    public function __destruct()
    {
        echo "User deleted";
    }
}

$sample = new Example("Афанасий", 22);

echo "Username: {$sample->name}\n";
```

**Instanceof**
--

Используется для понимания, является ли объект экземпляром класса. Выдаёт информацию в булиевом значении.
```php
class Example {
}
$sample = new Example;

var_dump($sample instanceof Example); // bool(true)
var_dump($sample instanceof Zapple); // bool(false)
```

**$this и self**
--

Переменная `$this` позволяет обращаться к свойствам и методам внутри класса исходя из контекста.

```php
class myClass {
	public string $name = "Ivan";

	public function getName() {
		return $this->name;
	}
}

$object = new myClass;
echo $object->getName();
```

Ключевое слово `self` позволяет обращаться к статическим свойствам и методам внутри класса, не учитывая экземпляр класса.

```php
class Merchandise
{
    public static string $name = "name";
    public static int $id = 0;
    public static float $price = 0;

    public static function setMerch(string $name, int $id, float $price): void
    {
        self::$name = $name;
        self::$id = $id;
        self::$price = $price;
    }
    static function getMerch(): object
    {
        $result = (object) array("name" => self::$name, "id" => self::$id, "price" => self::$price);

        return $result;
    }
}

Merchandise::setMerch("bread", 1, 99.99);

$getMerch = Merchandise::getMerch();

print_r($getMerch); // выдаст объект
```

Оператор `::` позволяет обращаться к статическим свойствами и методам класса без объявления экземпляра класса, а также к константам.

Константы
--

Константы по умолчанию public.
Констант

```php
class Merchandise
{
    const MYCOST = 999;
}

echo Merchandise::MYCOST;

Статические свойства и методы
--

Позволяет обращаться к свойствам и методам класса, без создания экземпляра класса.

```php
class User {
	public static $name;
}

User::$name = "John";
echo User::$name;
```

Константа `::class` полезна при работе с пространством имён.

```php
namespace sandbox;
class box {
//code
}

$box = new box;
echo $box::class;
```
Пространство имен
--
Пространство имён -  своего рода инкапсуляция элементов, которая содержит в себе классы, объекты, интерфейсы, трейты и прч. и позволяет обращаться к её артефактам, используя пространство имён, что помогает избегать ошибок.

Задать пространство имён следует до начала описания кода командой `namespace`.

```php
<?php

namespace phplearn;

// Дальше можно писать классы и прч.
```

Если какая-то конструкция описана без `namespace` то считается что она находится внутри глобального пространства имён.

Обращение к пространству имён:
```php
namespace users; // задали namespace

class User {
	public string $name;

	public __construct($name) {
		$this->name = $name;
	}
}
```

Допустим мы создали ещё один файл:
```php
namespace auth; // задали другой namespace

include "user.php"; // подключаем нужный скрипт
$newUser = new users\User("John"); // обращаемся к пространству имён

echo $newUser->name; // создан экземпляр класса из namespace users
```

Пространство имён может быть вложенным, как:
```php
namespace users\basicusers; 
```

Обращение к такому пространству будет:

```php
$newUser = new users\basicusers\User("Dick");
```
Принцип ООП: наследование
--

Наследование - создание дочернего класса, которые наследует свойства и методы родительского класса.
Обычно используется для расширения классов и их свойств. Например, роли пользователей.

```php
class User
{
    protected string $name;

    protected int $id;

    protected string $email;

    protected string $password;


    public function __construct($name, $id, $email, $password)

    {
        $this->name = $name;

        $this->id = $id;

        $this->email = $email;

        $this->password = $password;
    }
    
    public function getInfo()
    {
        $info = "name: $this->name, id: $this->id, email: $this->email, password: $this->password";

        return $info;
    }
}

class Admin extends User
{
    protected string $type;

    public function __construct($name, $id, $email, $password, $type)
    {
        parent::__construct($name, $id, $email, $password); // обращение к родительскому классу
        
        $this->type = $type;
    }

    public function getInfo()
    {
        $info = parent::getInfo(); // обращение к родительскому классу

        $info .= ", type: $this->type";

    }
} 

$administrator = new Admin($name = "John", $id = 22, $email = "lovedogs@gmail.com", $password = "12345678", $type = "admin");

var_dump($administrator);
```

Принцип ООП: Инкапсуляция
--

Инкапсуляция - изоляция доступа к методам и свойствам класса для того чтобы работать с этими методами исключительно в рамках данного класса \ экземпляра.

Также существует усиленная изоляция, где доступ к свойствам класса регулируется модификаторами доступа, а вывод и изменение данных происходит путём функций геттеров и сеттеров.

```php
class Sandbox
{
    private string $name;
    
    public function getName(): void
    {
        echo $this->name; // $this - это тоже инкапусляция
    }

    public function setName(string $name): void
    {
        $this->name = $name;
    }
}  

$example = new Sandbox;

$example->setName("John"); 

$example->getName();
```

Принцип ООП: Полиморфизм
--

Полиморфизм - следствие наследования. Разные поведения одного и того же метода в разных классах.
Помогает не использовать большое количество ветвлений, а создать взаимозаменяемые классы с разным поведением в зависимости от условия.

```php
abstract class User // создаём абстрактный класс

{
    abstract function getinfo(); // задаём абстрактный метод
}

class Client extends User
{
    public function getinfo()
    {
        echo "This is a client \n";
    }
}

class Admin extends User
{
    public function getinfo()
    {
        echo "This is the Admin \n";
    }
}

class Moderator extends User

{
    public function getinfo()
    {
        echo "This is a Moderator \n";
    }
}  

// добавляем экземпляры класса в массив, чтобы обратиться к каждому по-очереди
$users[] = new Client;
$users[] = new Admin;
$users[] = new Moderator;

foreach ($users as $user) {

    if ($user instanceof User) {
        $user->getinfo(); // в зависимости от класса метод будет отрабатывается по-разному
    } else {

        throw new Exception("Not an instance");
    }
}
```

Принцип ООП: Абстракция
--

Абстракция - создания абстрактного класса, свойств и методов из которых можно с помощью полиморфизма создавать дочерние классы, но нельзя создавать экземпляр класса.
Своего рода абстрактный класс это шаблон.

```php
abstract class Sandbox

{
    public int $id;

    abstract function getId();

}

class box extends Sandbox

{
    public function getId()
    {
        return $this->id;
    }
}

$box1 = new box;

$box1->id = 22;

echo $box1->getId();
```


Интерфейсы
--
Интерфейс - своего рода темплейт класса, который определяет какие методы обязательно должны быть определены в классе, без необходимости определять эти методы.

```php
interface Contents
{
    public function getContent();
    public function setContent($data);
    private function connection();
}

class Article implements Contents
{
    private string $content;

    public function getContent()
    {
        return $this->content;
    }

    public function setContent($data)
    {
        $this->content = $data;
    }

    private function connection()
    {
        try {
            include "connection.php";
        } catch (error) {
            throw new error;
        } 
    }
}

$article = new Article;

```

Класс может имплементировать несколько интерфейсов, указанных через запятую. Но нужно указать все методы этих интерфейсов.

Интерфейс может также унаследовать методы родительского интерфейса через команду `extends`.

```php
interface Contents

{
    public function getContent();
    public function setContent($data);
    private function connection();

}

interface News extends Contents
{
    public function expandNews();
}
```

Отличие абстрактного класса и интерфейса - в неабстрактном методе можно предопределять тело метода.
В интерфейсах нельзя.
А также в классах нельзя использовать множественное наследование.

В интерфейсах также можно указывать константы.

Трейты
--
Трейт позволяет повторно использовать один и тот же код в рамках классов.

```php
trait noNegative
{
    public function checkNehative($array)
    {
        return array_filter($array, function ($item) {
            return $item >= 0;
        });
    }
}
trait notEven
{
    public function checkEven($array)
    {
        return array_filter($array, function ($item) {
            return $item % 2 != 0;
        });
    }
}

class checkArray
{
    use noNegative, notEven;
}

$array = [0, 22, -1, 1, 31, 42, 99, 69, 77, -100];
$checkArray = new checkArray;  

$array = $checkArray->checkNehative($array);
$array = $checkArray->checkEven($array);

print_r($array);
```

Магические методы
--
`__clone` - магический метод, который позволяет клонировать экземпляр класса.

```php
class User
{
    private int $id = 0;
    private string $access = "user";

    public function __construct($id)
    {
        $this->id = $id;
    }

    public function setAccess($access)
    {
        $this->access = $access;
    }

    public function checkAccess()
    {
        if ($this->access == "user") {
            return "user";
        } else {
            return "admin";
        }
    }

    public function __clone()
    {
        $this->id++;
    }
}

$users = [];
$admins = [];

$users[] = new User($id = 22);

foreach ($users as $user) {
    if ($user->checkAccess() == "user") {
        $users[] = clone $user;
    } else {
        $admins[] = clone $user;
    }
}  

echo "Users: ";
print_r($users);

echo "Admins: ";
print_r($admins
```

#### Геттеры и сеттеры

`__get` - магический метод, который позволяет получить данные свойства класса.
`__set` - магический метод, который позволяет изменять свойства класса.

```php
class Sandbox
{
    private int $id = 42;
    public function __get($name)

    {
        echo "Getting $name: $this->id \n";
    }
    public function __set($name, $value)
    {
        echo "Setting $name: ";
    }
}

$example = new Sandbox;

echo $example->id;
echo $example->id = 0;
```

#### Перегрузка

Дают возможность перехватить несуществующий метод класса.

`__call` - перегрузка метода класса
`callStatic` - перегрузка статического метода класса

```php
class Sandbox
{
    public function __call($method, $args)
    {
        echo "Calling method $method.";
    }

    public static function __callStatic($method, $args)
    {
        echo "Calling static method $method";
    }
}

$example = new Sandbox;

$example->runDev();

$example::runDev();
```

`__isset()` - магический метод, если применить к несуществующему свойству `isset()` метода - выполняет действие.

```php
class Sandbox

{
    public int $id = 0;

    public function __isset($name)
    {
        echo "$name doesn't exist \n";
    }
}

$sandbox = new Sandbox;

isset($sandbox->dod);
```

`__unset()` - магический метод, который будет вызван если применить `unset()` к защищённому свойству.

```php
class Sandbox

{
    private int $id = 0;

    public function __unset($name)
    {
        echo "Error: Don't try to unset $name";
    }
}

$sandbox = new Sandbox;

unset($sandbox->id);
```

`__toString()` - магический метод который определяет поведение, если привести свойства класса  в строку.

```php
class Sandbox
{
    public function __toString()
    {
        return "What?";
    }
}

$sandbox = new Sandbox;

echo $sandbox;
```

`__invoke()` - магический метод, который используется когда вызывают экземпляр класса как функцию.

```php
class Sandbox

{

    public function __invoke($data)
    {
        return $data + 1;
    }
}

$sandbox = new Sandbox;

echo $sandbox(5);
```

`__sleep()` - магический метод, который применяется если к свойству метода применяется `serialize()`. Должен возвращать массивы, которые будут серализованы, иначе сериализирует Null. Обычно используется для закрытия соединения с БД.
`__wakeup()` - магический метод, который применяется для восстановления соединения с БД при сериализации.
#### Readonly классы

Классу моно добавить атрибут доступности `readonly`, который не разрешит создавать динамические свойства.

- Нельзя предопределить свойство класса в readonly. Свойство класса можно назначить через конструктор.
- Нельзя поменять свойство класса в readonly.

```php
readonly class Server
{
    public string $URL;

    // public string $port = '3000'; вызовет ошибку

    public function __construct($url)
    {
        $this->URL = $url;
    }
}

$server = new Server('https://127.0.0.1:8000');

echo $server->URL;

// $server->URL = 'none'; вызовет ошибку
```

Недопустимые изменения сигнатур методов
--
При наследовании классов можно морфить свойства и методы в рамках допущенной сигнатуры.

- Нельзя сделать public свойство и метод private. А вот private свойство и метод можно сделать public.
- Нельзя делать обязательный аргумент необязательным и наоборот.
