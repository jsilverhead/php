ООП - подход в разработке, подразумевающий организацию кода при помощи Объектов (классов).

Пример класса:
```php
Class Example {
	public string $name;
	public int $id;
}
```

Для работы и для доступы к классу необходимо создавать его экземпляр путём создания переменной и команду new:
```php
Class Example {
	public string $name;
	public int $id;
}

$sample1 = new Example;
```

Переменные в классах называются "Свойства класса".
Функции в классах называются "Методы класса".

Пример:
```php
Class Example {
	public string $name;
	public int $id;

	public function getName(){
		return this->name;
	}

$sample = new Example;
echo $sample->getName();
}
```

**Область видимости:**
--

Существуют настройки области видимости.
`public` - доступна во всех местах кода
`private` - доступна только в рамках экземпляра класса
`protected` - доступна в рамках класса и дочерних классов

`Геттеры` - публичные методы, которые позволяют получить доступ к просмотру свойства класса.
`Сеттеры` - публичные методы, которые позволяют получить доступ к изменению свойства класса.

Пример:
```php
class Example

{
    private int $id = 21;
    
    public function getId()
    {
        return $this->id;
    }
}

$sample = new Example;
echo $sample->getId(); // для получения доступа к приватному свойству использован геттер
```

```php
class Example

{
    protected int $id = 99;
}

class Sample extends Example
{
    function getId()
    {
        echo $this->id;
    }
}
 
$samp = new Sample;

$samp->getId(); // выведет id

$samp->$id = 30; // выведет ошибку
```

**Конструкторы и деструкторы**
--

Существуют магические функции, которые используются при создании экземпляра класса.
`__construct()` - магический метод, который автоматически вызывается при создании экземпляра класса.

Пример:
```php
class Example
{
    public string $name;
    public int $id;

    public function __construct($name, $id)
    {
        echo "New user created\n";
        $this->name = $name;
        $this->id = $id;
    }
}

$sample = new Example("Афанасий", 22);

echo "Username: {$sample->name}";
```

`__desctruct()` - магический метод, который уничтожает класс после его "отработки", срабатывает в конце "отработки" класса. Делается это для освобождения памяти.

Пример:
```php
class Example
{
    public string $name;
    public int $id;

    public function __construct($name, $id)
    {
        echo "New user created\n";
        $this->name = $name;
        $this->id = $id;
    }

    public function __destruct()
    {
        echo "User deleted";
    }
}

$sample = new Example("Афанасий", 22);

echo "Username: {$sample->name}\n";
```

**Instanceof**
--

Используется для понимания, является ли объект экземпляром класса. Выдаёт информацию в булиевом значении.
```php
class Example {
}
$sample = new Example;

var_dump($sample instanceof Example); // bool(true)
var_dump($sample instanceof Zapple); // bool(false)
```

**$this и self**
--

Оператор `::` - позволяет обращаться к статическим свойствам или методам, а также к константам.

```php
class Merchandise
{
    const MYCOST = 999;
}

echo Merchandise::MYCOST;
```


Переменная `$this` позволяет обращаться к свойствам и методам внутри класса исходя из контекста.

```php
class myClass {
	public string $name = "Ivan";

	public function getName() {
		return $this->name;
	}
}

$object = new myClass;
echo $object->getName();

```

Ключевое слово `self` позволяет обращаться к статическим свойствам и методам внутри класса, не учитывая экземпляр класса.

```php
class Merchandise
{
    static string $name = "name";
    static int $id = 0;
    static float $price = 0;

    static function setMerch(string $name, int $id, float $price): void
    {
        self::$name = $name;
        self::$id = $id;
        self::$price = $price;
    }
    static function getMerch(): object
    {
        $result = (object) array("name" => self::$name, "id" => self::$id, "price" => self::$price);

        return $result;
    }
}

Merchandise::setMerch("bread", 1, 99.99);

$getMerch = Merchandise::getMerch();

print_r($getMerch); // выдаст объект
```

Пространство имен
--
Пространство имён -  своего рода инкапсуляция элементов, которая содержит в себе классы, объекты, интерфейсы, трейты и прч. и позволяет обращаться к её артефактам, используя пространство имён, что помогает избегать ошибок.

Задать пространство имён следует до начала описания кода командой `namespace`.

```php
<?php

namespace phplearn;

// Дальше можно писать классы и прч.
```

Если какая-то конструкция описана без `namespace` то считается что она находится внутри глобального пространства имён.

Обращение к пространству имён:
```php
namespace users; // задали namespace

class User {
	public string $name;

	public __construct($name) {
		$this->name = $name;
	}
}
```

Допустим мы создали ещё один файл:
```php
namespace auth; // задали другой namespace

include "user.php"; // подключаем нужный скрипт
$newUser = new users\User("John"); // обращаемся к пространству имён

echo $newUser->name; // создан экземпляр класса из namespace users
```

Пространство имён может быть вложенным, как:
```php
namespace users\basicusers; 
```

Обращение к такому пространству будет:

```php
$newUser = new users\basicusers\User("Dick");
```
Принцип ООП: наследование
--

Наследование - создание дочернего класса, которые наследует свойства и методы родительского класса.
Обычно используется для расширения классов и их свойств. Например, роли пользователей.

```php
class User
{
    protected string $name;

    protected int $id;

    protected string $email;

    protected string $password;


    public function __construct($name, $id, $email, $password)

    {
        $this->name = $name;

        $this->id = $id;

        $this->email = $email;

        $this->password = $password;
    }
    
    public function getInfo()
    {
        $info = "name: $this->name, id: $this->id, email: $this->email, password: $this->password";

        return $info;
    }
}

class Admin extends User
{
    protected string $type;

    public function __construct($name, $id, $email, $password, $type)
    {
        parent::__construct($name, $id, $email, $password); // обращение к родительскому классу
        
        $this->type = $type;
    }

    public function getInfo()
    {
        $info = parent::getInfo(); // обращение к родительскому классу

        $info .= ", type: $this->type";

    }
} 

$administrator = new Admin($name = "John", $id = 22, $email = "lovedogs@gmail.com", $password = "12345678", $type = "admin");

var_dump($administrator);
```